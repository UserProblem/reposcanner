/*
 * Repository Secrets Scanner
 *
 * This is a simple backend API to allow a user to configure repositories for scanning, trigger a scan of those repositories, and retrieve the results.
 *
 * API version: 0.0.1
 * Contact: sean.critica@gmail.com
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"bytes"
	"encoding/json"
	"io/ioutil"
	"log"
	"net/http"
	"strconv"
	"strings"

	"github.com/UserProblem/reposcanner/models"
	"github.com/gorilla/mux"
)

func (a *App) AddScan(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id, err := strconv.Atoi(vars["id"])
	if err != nil {
		respondWithError(w, http.StatusBadRequest, "invalid repository id")
		return
	}

	var rr *models.RepositoryRecord
	if rr, err = a.RepoStore.Retrieve(int64(id)); err != nil {
		respondWithError(w, http.StatusNotFound, "repository id not found")
		return
	}

	si := models.DefaultScanInfo()
	si.RepoId = int64(id)
	si.QueuedAt = currentTimestamptz()

	var sr *models.ScanRecord
	sr, err = a.ScanStore.Insert(si)
	if err != nil {
		log.Printf("Failed to add scan to the data store: %v\n", err.Error())
		respondWithError(w, http.StatusInternalServerError,
			"failed to add scan to the data store")
		return
	}

	body := &models.ApiResponse{
		Id:      0,
		Message: sr.Id,
	}

	respondWithJSON(w, http.StatusCreated, body)

	a.AddScanRequest(rr.Info, sr)
}

func (a *App) DeleteScan(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id := vars["id"]
	if !ValidScanId(id) {
		respondWithError(w, http.StatusBadRequest, "invalid scan id")
		return
	}

	if err := a.ScanStore.Delete(id); err != nil {
		if !strings.HasPrefix(err.Error(), "id not found") {
			log.Printf("Failed to delete scan from the data store: %v\n", err.Error())
			respondWithError(w, http.StatusInternalServerError, "failed to delete scan")
		} else {
			respondWithError(w, http.StatusNotFound, "scan id not found")
		}
		return
	}

	w.WriteHeader(http.StatusOK)

	a.RemoveScanRequest(id)
	a.ScanStore.DeleteFindings(id)
}

func (a *App) GetScan(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id := vars["id"]
	if !ValidScanId(id) {
		respondWithError(w, http.StatusBadRequest, "invalid scan id")
		return
	}

	sr, err := a.ScanStore.Retrieve(id)
	if err != nil {
		respondWithError(w, http.StatusNotFound, "scan id not found")
		return
	}

	sres := &models.ScanResults{
		Id:       sr.Id,
		Info:     sr.Info,
		Findings: make([]models.FindingsInfo, 0),
	}

	if findings, err := a.ScanStore.ListFindings(id); err != nil {
		respondWithError(w, http.StatusInternalServerError, "cannot retrieve findings")
	} else {
		for _, fi := range findings {
			sres.Findings = append(sres.Findings, *fi)
		}
	}

	respondWithJSON(w, http.StatusOK, sres)
}

func (a *App) ListScans(w http.ResponseWriter, r *http.Request) {
	var pp models.PaginationParams
	if r.Body != nil {
		contents, _ := ioutil.ReadAll(r.Body)
		if strings.TrimSpace(string(contents)) == "" {
			r.Body = nil
		} else {
			r.Body = ioutil.NopCloser(bytes.NewReader(contents))
		}
	}

	if r.Body != nil {
		decoder := json.NewDecoder(r.Body)
		if err := decoder.Decode(&pp); err != nil {
			respondWithError(w, http.StatusBadRequest, "invalid request body")
			return
		}
	} else {
		pp = models.PaginationParams{Offset: 0, PageSize: 20}
	}

	sl, err := a.ScanStore.List(&pp)
	if err != nil {
		if err.Error() == "invalid offset" || err.Error() == "invalid page size" {
			respondWithError(w, http.StatusNotFound, "parameters out-of-bounds")
		} else {
			log.Printf("Failed to retrieve scan list: %v", err.Error())
			respondWithError(w, http.StatusInternalServerError,
				"failed to retrieve scan list from the data store")
		}
		return
	}

	respondWithJSON(w, http.StatusOK, sl)
}
